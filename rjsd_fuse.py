from utils import RJSD
import torch
import numpy as np

def rjsd_fuse(
    X,
    Y,
    seed,
    order_approx = 4,
    alpha=0.05,
    kernels=("laplace", "gaussian"),
    lambda_multiplier=1,
    number_bandwidths=10,
    number_permutations=2000,
    return_p_val=False,
):
    """
    Two-Sample RJSD-FUSE test.

    Code adapted from the JAX version of MMD-FUSE by Schrab et al. (2021).

    Given data from one distribution and data from another distribution,
    return 0 if the test fails to reject the null
    (i.e. data comes from the same distribution),
    or return 1 if the test rejects the null
    (i.e. data comes from different distributions).


    Parameters
    ----------
    X : tensor
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    Y: array_like
        The shape of X must be of the form (n, d) where m is the number
        of samples and d is the dimension.
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    alpha: scalar
        The value of alpha (level of the test) must be between 0 and 1.
    kernels: str or list
        The list should contain strings.
        The value of the strings must be: "gaussian", "laplace", "imq", "matern_0.5_l1",
        "matern_1.5_l1", "matern_2.5_l1", "matern_3.5_l1", "matern_4.5_l1",
        "matern_0.5_l2", "matern_1.5_l2", "matern_2.5_l2", "matern_3.5_l2",
        "matern_4.5_l2".
    lambda_multiplier: scalar
        The value of lambda_multiplier must be positive.
        The regulariser lambda is taken to be jnp.sqrt(minimum_m_n * (minimum_m_n - 1)) * lambda_multiplier
        where minimum_m_n is the minimum of the sample sizes of X and Y.
    number_bandwidths: int
        The number of bandwidths per kernel to include in the collection.
    number_permutations: int
        Number of permuted test statistics to approximate the quantiles.
    return_p_val: bool
        If true, the p-value is returned.
        If false, the test output Indicator(p_val <= alpha) is returned.

    Returns
    -------
    output : int
        0 if the aggregated RJSD-FUSE test fails to reject the null
            (i.e. data comes from the same distribution)
        1 if the aggregated RJSD-FUSE test rejects the null
            (i.e. data comes from different distributions)
    """
    # Assertions
    if Y.shape[0] > X.shape[0]:
        X, Y = Y, X
    m = X.shape[0]
    n = Y.shape[0]
    assert n <= m
    assert n >= 2 and m >= 2
    assert 0 < alpha and alpha < 1
    assert lambda_multiplier > 0
    assert number_bandwidths > 1 and type(number_bandwidths) == int
    assert number_permutations > 0 and type(number_permutations) == int
    if type(kernels) is str:
        # convert to list
        kernels = (kernels,)
    for kernel in kernels:
        assert kernel in (
            "imq",
            "rq",
            "gaussian",
            "matern_0.5_l2",
            "matern_1.5_l2",
            "matern_2.5_l2",
            "matern_3.5_l2",
            "matern_4.5_l2",
            "laplace",
            "matern_0.5_l1",
            "matern_1.5_l1",
            "matern_2.5_l1",
            "matern_3.5_l1",
            "matern_4.5_l1",
        )

    # Lists of kernels for l1 and l2
    all_kernels_l1 = (
        "laplace",
        "matern_0.5_l1",
        "matern_1.5_l1",
        "matern_2.5_l1",
        "matern_3.5_l1",
        "matern_4.5_l1",
    )
    all_kernels_l2 = (
        "imq",
        "rq",
        "gaussian",
        "matern_0.5_l2",
        "matern_1.5_l2",
        "matern_2.5_l2",
        "matern_3.5_l2",
        "matern_4.5_l2",
    )
    number_kernels = len(kernels)
    kernels_l1 = [k for k in kernels if k in all_kernels_l1]
    kernels_l2 = [k for k in kernels if k in all_kernels_l2]

    # Setup torch seeds
    torch.manual_seed(seed)
    B = number_permutations
    # generate random permutation indices
    idx = torch.stack([torch.randperm(m + n) for _ in range(B + 1)])
  

    # Compute all permuted RJSD estimates
    N = number_bandwidths * number_kernels
    M = torch.zeros((N, B + 1))
    kernel_count = -1  # first kernel will have kernel_count = 0
    for r in range(2):
        kernels_l = (kernels_l1, kernels_l2)[r]
        l = ("l1", "l2")[r]
        if len(kernels_l) > 0:
            # Pairwise distance matrix
            Z = torch.cat((X, Y),dim=0)
            pairwise_matrix = torch.cdist(Z, Z, p = r+1)  # l1 and l2 distances

            # Collection of bandwidths
            def compute_bandwidths(distances, number_bandwidths):
                median = torch.median(distances)
                distances = distances + (distances == 0) * median
                dd = distances.sort().values
                lambda_min = dd[(np.floor(len(dd) * 0.05).astype(int))] / 2
                lambda_max = dd[(np.floor(len(dd) * 0.95).astype(int))] * 2
                bandwidths = torch.linspace(lambda_min, lambda_max, number_bandwidths)
                return bandwidths

            triu_indices = torch.triu_indices(pairwise_matrix.shape[0],pairwise_matrix.shape[0], offset=1)
            distances = pairwise_matrix[triu_indices[0], triu_indices[1]]
            bandwidths = compute_bandwidths(distances, number_bandwidths)

            # Compute all permuted RJSD estimates for either l1 or l2
            for j in range(len(kernels_l)):
                kernel = kernels_l[j]
                kernel_count += 1
                for i in range(number_bandwidths):
                    # compute kernel matrix and set diagonal to zero
                    bandwidth = bandwidths[i]
                    Kz = kernel_matrix(pairwise_matrix, l, kernel, bandwidth)
                    # compute standard deviation
                    unscaled_std = torch.sqrt(torch.sum(Kz**2))
                    # compute RJSD permuted values
                    Kx = Kz[:m, :m]
                    Ky = Kz[m:, m:] 
                    M[kernel_count * number_bandwidths + i,-1] =  (np.sqrt(n*(n-1))/unscaled_std)*RJSD(Kx,Ky,Kz, approx = True, order_approx = order_approx)
                    for b in range(B):
                        Kz_perm = Kz[idx[b,:], :]
                        Kz_perm = Kz_perm[:, idx[b,:]]
                        Kx_perm = Kz_perm[:m, :m]
                        Ky_perm = Kz_perm[m:, m:]
                        
                        M[kernel_count * number_bandwidths + i, b] = (np.sqrt(n*(n-1))/unscaled_std)*RJSD(Kx_perm,Ky_perm,Kz_perm, approx = True, order_approx = order_approx)

    # Compute permuted and original statistics

    all_statistics = torch.logsumexp(lambda_multiplier * M, dim=0) + np.log((1/N))  # (B1+1,) log(1/N*sum(exp(RJSD_k)))
    original_statistic = all_statistics[-1]  # (1,)

    # Compute statistics and test output
    p_val = torch.mean((all_statistics[:-1] >= original_statistic).float())
    output = p_val <= alpha


    # Return output
    if return_p_val:
        return int(output.item()), p_val
    else:
        return int(output.item())
    
def kernel_matrix(pairwise_matrix, l, kernel, bandwidth):
    """
    Compute kernel matrix for a given kernel and bandwidth.

    inputs: pairwise_matrix: (2m,2m) matrix of pairwise distances
            l: "l1" or "l2" 
            kernel: string from ("gaussian", "laplace")
    output: (2m,2m) pairwise distance matrix

    Warning: The pair of variables l and kernel must be valid.
    """

    d = pairwise_matrix / bandwidth
    if kernel == "gaussian" and l == "l2":
        return torch.exp(-(d**2) / 2)
    elif kernel == "laplace" and l == "l1":
        return torch.exp(-d * np.sqrt(2))
    else:
        raise ValueError('The values of "l" and "kernel" are not valid.')